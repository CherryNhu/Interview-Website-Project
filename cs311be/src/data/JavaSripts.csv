STT,Câu hỏi,Trả lời
1,1. Sự khác biệt giữa == và === trong JavaScript là gì?,"Trong JavaScript, == là toán tử so sánh lỏng (loose equality), so sánh hai giá trị bằng nhau sau khi thực hiện ép kiểu nếu cần. Điều này có nghĩa là nó chuyển đổi các toán hạng sang cùng kiểu trước khi so sánh. === là toán tử so sánh nghiêm ngặt (strict equality), so sánh cả giá trị và kiểu dữ liệu mà không thực hiện chuyển đổi kiểu."
2,"2. Kết quả của biểu thức 3+2+""7"" sẽ là gì?","Kết quả: 3 + 2 được đánh giá trước, và vì cả hai là số, kết quả là 5. Sau đó, 5 + ""7"" được tính. Vì một trong các toán hạng là chuỗi (""7""), JavaScript chuyển đổi số 5 thành chuỗi và nối nó với ""7"", dẫn đến ""57""."
3,3. Những gì mới trong ECMAScript 2025 (ES2025)?,"ECMAScript 2025 (ES2025) Các tính năng chính: Promise.withResolvers() → Trả về một promise với resolve và reject của nó, đơn giản hóa kiểm soát bất đồng bộ. Các phương thức mảng bất biến → Các phương thức mới như findLast(), toReversed() và toSorted() trả về mảng mới thay vì thay đổi mảng gốc. Cờ v cho RegExp → Thêm xử lý Unicode tốt hơn trong biểu thức chính quy. Ngữ pháp Hashbang → Chính thức cho phép #! ở đầu file JS cho các script CLI."
4,4. JavaScript được biên dịch hay diễn giải?,"JavaScript chủ yếu được diễn giải, nhưng các trình duyệt hiện đại cũng biên dịch nó theo thời gian thực (JIT) để tăng tốc độ. Trình duyệt đọc mã JavaScript của bạn từng dòng và chạy trực tiếp. Các trình duyệt hiện đại (như engine V8 của Chrome) trước tiên dịch các phần mã của bạn thành mã máy trong khi chạy, để máy tính có thể thực thi nhanh hơn."
5,5. JavaScript và Java có liên quan không?,"Không, mặc dù tên nghe tương tự nhưng chúng không liên quan dưới bất kỳ khía cạnh nào, dưới đây là một số khác biệt chính:"
6,6. Có bao nhiêu cách để truy cập một phần tử HTML trong mã JavaScript?,Có bốn cách có thể để truy cập phần tử HTML trong JavaScript: Phương thức getElementById(): Dùng để lấy phần tử theo tên id. Phương thức getElementsByClass(): Dùng để lấy tất cả các phần tử có tên lớp đã cho. Phương thức getElementsByTagName(): Dùng để lấy tất cả các phần tử có tên thẻ đã cho. Phương thức querySelector(): Hàm này lấy bộ chọn kiểu CSS và trả về phần tử được chọn đầu tiên.
7,7. Sự khác biệt về giá trị trả về giữa x++ và ++x là gì?,"Cả hai đều tăng giá trị, nhưng trả về giá trị khác nhau. x++: hậu tăng → trả về giá trị cũ, sau đó tăng. ++x: tiền tăng → tăng trước, sau đó trả về giá trị mới."
8,"8. Sự khác biệt giữa var, let và const là gì và Temporal Dead Zone là gì?","JavaScript cung cấp ba cách để khai báo biến: var, let và const, nhưng chúng khác nhau về phạm vi, hành vi hoisting và quy tắc gán lại. var: Khai báo biến với phạm vi hàm hoặc toàn cục và cho phép khai báo lại và cập nhật trong cùng phạm vi. let: Khai báo biến với phạm vi khối, cho phép cập nhật nhưng không cho phép khai báo lại trong cùng khối. const: Khai báo biến phạm vi khối không thể gán lại sau khi gán ban đầu. Temporal Dead Zone (TDZ): Là khoảng thời gian giữa việc vào phạm vi và điểm mà biến let hoặc const được khai báo. Trong thời gian này, truy cập biến gây lỗi ReferenceError, vì biến tồn tại nhưng chưa được khởi tạo."
9,9. Phạm vi biến (Variable Scope) trong JavaScript là gì?,"Trong JavaScript, mỗi biến được truy cập và sửa đổi qua một trong các phạm vi sau: Phạm vi toàn cục: Mức ngoài cùng (có thể truy cập mọi nơi). Phạm vi cục bộ: Các hàm con có thể truy cập biến từ hàm cha do phạm vi từ vựng. Phạm vi hàm: Biến bị giới hạn trong hàm chúng được khai báo. Phạm vi khối: Biến khai báo với let hoặc const bị giới hạn trong khối gần nhất (vòng lặp, điều kiện, v.v.)."
10,10. Sự khác biệt giữa phạm vi từ vựng (Lexical Scoping) và phạm vi động (Dynamic Scoping) là gì?,"Phạm vi từ vựng (Lexical Scoping - Phạm vi tĩnh): Phạm vi của biến được xác định bởi vị trí của nó trong mã nguồn tại thời điểm viết. JavaScript sử dụng phạm vi từ vựng. Hàm con tra cứu biến trong hàm ngoài nơi nó được định nghĩa, không phải nơi nó được gọi. Phạm vi động (Không có trong JS): Phạm vi được xác định bởi ngăn xếp gọi tại thời gian chạy, không phải nơi hàm được viết. Các ngôn ngữ như phiên bản Lisp cũ hoặc Bash sử dụng phạm vi động. Hàm sử dụng biến từ hàm gọi nó, ngay cả nếu được định nghĩa ở nơi khác."
11,"11. Ý nghĩa của isNaN là gì, và nó khác Number.isNaN như thế nào?","Hàm isNaN xác định xem giá trị truyền vào có phải là NaN (Not a Number) và thuộc kiểu ""Number"" hay không. Trong JavaScript, giá trị NaN được coi là một loại số. Nó trả về true nếu đối số không phải là số, ngược lại trả về false. Number.isNaN(x) → trả về true chỉ nếu x là giá trị NaN. Không ép kiểu. isNaN(x) → chuyển x thành số rồi kiểm tra xem kết quả có phải NaN không."
12,12. Đoạn mã này sẽ log gì?,"Kết quả: Giải thích: Khi gán arr[10] bạn tạo các khe rỗng từ chỉ số 3 đến 9, làm độ dài mới lớn hơn chỉ số cao nhất một: 10 + 1 = 11."
13,13. Vô cực âm (Negative Infinity) là gì?,Vô cực âm là giá trị hằng số đại diện cho giá trị thấp nhất có sẵn. Nghĩa là không có số nào nhỏ hơn giá trị này. Nó có thể được tạo bằng hàm tự tạo hoặc hoạt động số học. JavaScript hiển thị giá trị NEGATIVE_INFINITY như -Infinity.
14,"14. Tại sao typeof null === ""object""?","Đây là lỗi lịch sử lâu dài trong mã hóa thẻ typeof gốc không thể sửa mà không phá vỡ web. null là kiểu nguyên thủy, nhưng typeof null trả về ""object"". Mẹo thực tế: Kiểm tra null bằng value === null hoặc value == null (để khớp null hoặc undefined một cách cố ý)."
15,15. Có thể chia mã JavaScript thành nhiều dòng không?,"Có, có thể chia mã JavaScript thành nhiều dòng trong câu lệnh chuỗi. Nó có thể được chia bằng cách sử dụng '\n' (backslash n). Ví dụ: Dòng chia mã được tránh bởi JavaScript không ưu tiên."
16,"16. Giá trị ""truthy"" và ""falsy"" trong JavaScript là gì?","Falsy: false, 0, """" (chuỗi rỗng), null, undefined, NaN. Truthy: Mọi thứ khác (ví dụ: bất kỳ chuỗi không rỗng, bất kỳ số không zero, đối tượng, mảng)."
17,17. Biến chưa khai báo (undeclared) và chưa định nghĩa (undefined) là gì?,"Undefined: Xảy ra khi biến được khai báo nhưng không gán giá trị. Undefined không phải từ khóa. Undeclared: Xảy ra khi cố truy cập biến chưa được khởi tạo hoặc khai báo trước đó bằng từ khóa var hoặc const. Nếu dùng toán tử 'typeof' để lấy giá trị biến chưa khai báo, sẽ gặp lỗi thời gian chạy với giá trị trả về là ""undefined"". Phạm vi của biến chưa khai báo luôn là toàn cục."
18,18. Kết quả của biểu thức này sẽ là gì?,Kết quả: Giải thích: Toán tử hợp nhất nullish ?? trả về bên phải chỉ nếu bên trái là null hoặc undefined. Vậy: null ?? 'default' → 'default' undefined ?? 'default' → 'default' false ?? 'default' → false (vì false không phải null hoặc undefined)
19,"20. Biến toàn cục là gì? Chúng được khai báo như thế nào, và vấn đề liên quan đến chúng là gì?","Ngược lại, biến toàn cục là biến được định nghĩa ngoài hàm. Những biến này có phạm vi toàn cục, vì vậy chúng có thể được sử dụng bởi bất kỳ hàm nào mà không cần truyền chúng như tham số. Ví dụ: Kết quả Bên trong myFunction - Kiểu của petName: string Bên trong myFunction - petName: Rocky Bên ngoài myFunction - Kiểu của petName: string Bên ngoài myFunction - petName: Rocky Khó debug và kiểm tra mã dựa vào biến toàn cục."
20,21. Null trong JavaScript nghĩa là gì?,Giá trị null đại diện cho không có giá trị hoặc không có đối tượng. Nó được biết đến như giá trị/đối tượng rỗng.
21,22. Làm thế nào để xóa giá trị thuộc tính cụ thể?,Từ khóa delete xóa toàn bộ thuộc tính và tất cả giá trị cùng lúc như
22,23. Kết quả của đoạn mã này sẽ là gì?,"Kết quả: Giải thích: x++ trả về giá trị hiện tại (0), sau đó tăng → x trở thành 1. ++x tăng trước (1 → 2), sau đó trả về giá trị mới (2)."
23,24. Sự khác biệt giữa null và undefined trong JavaScript là gì?,"undefined: Giá trị nguyên thủy tự động gán cho: Biến chưa khởi tạo Tham số hàm thiếu Thuộc tính đối tượng thiếu Nó nghĩa là: ""giá trị chưa được gán"" null: Giá trị nguyên thủy bạn gán cố ý để đại diện: ""không có giá trị"", ""rỗng"" hoặc ""không tồn tại"" Nó nghĩa là: ""giá trị được cố ý rỗng"""
24,25. Template literals là gì và khi nào sử dụng chúng?,"Các chuỗi backtick hỗ trợ nội suy, văn bản đa dòng và xử lý được gắn thẻ. Nội suy ${expr} mà không cần nối thủ công. Giữ nguyên dòng mới/thụt lề như viết. Template được gắn thẻ cho phân tích nâng cao (ví dụ: khử trùng, i18n)."
25,26. Kết quả của đoạn mã này là gì?,"Kết quả: Giải thích: Mảng là đối tượng và được so sánh theo tham chiếu. a và b là các đối tượng riêng biệt, vì vậy cả so sánh lỏng (==) và nghiêm ngặt (===) đều cho false."
26,27. Closure có thể rò rỉ bộ nhớ không?,"Các closure JavaScript nắm bắt biến từ phạm vi ngoài, nhưng nếu không quản lý đúng, chúng có thể dẫn đến rò rỉ bộ nhớ. Khả năng rò rỉ bộ nhớ: Closure có thể rò rỉ bộ nhớ khi vô tình giữ tham chiếu đến biến hoặc đối tượng không còn cần. Điều này ngăn bộ thu gom rác giải phóng bộ nhớ đó."
27,28. JavaScript có cho phép kế thừa đa không?,"JavaScript không hỗ trợ kế thừa đa theo nghĩa truyền thống, nhưng cung cấp cách tái sử dụng và kết hợp chức năng. Lớp: Các lớp JavaScript chỉ cho phép kế thừa đơn, nghĩa là lớp chỉ có thể mở rộng một lớp cha. Nguyên mẫu: Đối tượng chỉ có thể kế thừa từ một nguyên mẫu tại một thời điểm, không phải nhiều. Mixins: Để đạt hành vi tương tự kế thừa đa, JavaScript sử dụng mixins—hàm hoặc đối tượng sao chép thuộc tính và phương thức vào lớp hoặc đối tượng."
28,29. JavaScript là kiểu tĩnh hay động?,"JavaScript là kiểu động vì chúng ta không cần nói với JavaScript loại dữ liệu (số, văn bản, đúng/sai, v.v.) mà biến sẽ chứa khi tạo nó. Kiểu được quyết định tự động khi chương trình chạy."
29,30. Từ khóa 'this' trong JavaScript là gì?,"Các hàm trong JavaScript là đối tượng thiết yếu. Giống đối tượng, nó có thể gán cho biến, truyền cho hàm khác và trả về từ hàm. Và giống đối tượng, chúng có thuộc tính riêng. 'this' lưu ngữ cảnh thực thi hiện tại của chương trình JavaScript. Do đó, khi sử dụng bên trong hàm, giá trị của 'this' sẽ thay đổi tùy thuộc vào cách hàm được định nghĩa, cách nó được gọi và ngữ cảnh thực thi mặc định."
30,"31. Giải thích cách hoạt động của timer trong JavaScript. Cũng giải thích nhược điểm của việc sử dụng timer, nếu có.","JavaScript cung cấp timer để lập lịch nhiệm vụ sau độ trễ hoặc theo khoảng thời gian đều đặn. Chúng không phải phần của engine JS, mà đến từ trình duyệt (Web APIs) hoặc môi trường Node.js. 1. setTimeout: Thực thi hàm một lần sau độ trễ chỉ định (miligiây). 2. setInterval: Thực thi hàm lặp lại theo khoảng thời gian chỉ định cho đến khi xóa. 3. clearTimeout/clearInterval: Dùng để dừng timer đã lập lịch. Timer trong JS (setTimeout, setInterval) cho phép lập lịch nhiệm vụ bất đồng bộ. Nhưng chúng không chính xác (do độ trễ vòng lặp sự kiện), có thể lãng phí tài nguyên nếu lạm dụng và nên được xóa đúng cách để tránh rò rỉ."
31,32. Đoạn mã này sẽ log gì?,"Kết quả: Giải thích: Sử dụng let i trong vòng lặp cho mỗi callback ràng buộc i riêng. Các timeout kích hoạt sau 0ms, 100ms và 200ms, log 0, sau đó 1, sau đó 2."
32,33. Sự khác biệt giữa ViewState và SessionState là gì?,ViewState: Nó cụ thể cho một trang đơn trong phiên. SessionState: Nó cụ thể cho người dùng có thể truy cập tất cả dữ liệu trên các trang web.
33,34. Làm thế nào để submit form bằng JavaScript?,Bạn có thể sử dụng phương thức document.form[0].submit() để submit form trong JavaScript.
34,35. JavaScript có hỗ trợ chuyển đổi kiểu tự động không?,"Có, JavaScript hỗ trợ chuyển đổi kiểu tự động."
35,36. Template literal trong JavaScript là gì?,Template literal trong JavaScript là cách định nghĩa chuỗi cho phép biểu thức nhúng và định dạng đa dòng. Nó sử dụng backtick (`) thay vì dấu ngoặc kép và hỗ trợ ${} để nhúng biến hoặc biểu thức bên trong chuỗi.
36,37. Hàm bậc cao (higher-order function) trong JavaScript là gì?,"Hàm bậc cao trong JavaScript là hàm nhận một hoặc nhiều hàm làm đối số, hoặc trả về hàm làm kết quả. Những hàm này cho phép mã trừu tượng và tái sử dụng hơn, kích hoạt mẫu lập trình hàm. Ví dụ, map() và filter() là hàm bậc cao vì chúng nhận hàm callback làm đối số."
37,38. Sự khác biệt giữa phương thức call() và apply() là gì?,"Cả hai phương thức được sử dụng trong tình huống khác nhau. Phương thức call(): Nó gọi phương thức, lấy đối tượng chủ sở hữu làm đối số. Từ khóa this đề cập đến 'chủ sở hữu' của hàm hoặc đối tượng nó thuộc về. Chúng ta có thể gọi phương thức có thể dùng trên các đối tượng khác nhau. Phương thức apply(): Phương thức apply() dùng để viết phương thức có thể dùng trên các đối tượng khác nhau. Nó khác với hàm call() vì nhận đối số dưới dạng mảng."
38,40. Phạm vi từ vựng (Lexical Scope) trong JavaScript là gì?,"Phạm vi từ vựng trong JavaScript đề cập đến cách biến được giải quyết dựa trên vị trí của chúng trong mã nguồn. Phạm vi của biến được xác định bởi vị trí mã nơi nó được định nghĩa, và nó có thể truy cập bởi bất kỳ hàm lồng hoặc khối nào. Điều này nghĩa là hàm có quyền truy cập biến trong phạm vi riêng và phạm vi ngoài (từ vựng), nhưng không phải biến trong phạm vi con. Trong ví dụ này, inner() có thể truy cập biến outer vì phạm vi từ vựng."
39,"41. Từ khóa this là gì, và vị trí gọi (call-site) ảnh hưởng đến nó như thế nào?","JavaScript sử dụng từ khóa this như tham chiếu đến đối tượng đang thực thi mã, nhưng giá trị của nó phụ thuộc vào vị trí gọi (cách và nơi hàm được gọi). Ngữ cảnh toàn cục/Hàm: Trong chế độ không nghiêm ngặt, this đề cập đến đối tượng toàn cục (window trong trình duyệt). Trong chế độ nghiêm ngặt, nó là undefined. Phương thức đối tượng: Khi hàm được gọi như phương thức của đối tượng, this đề cập đến đối tượng đó. Hàm tạo/Hàm lớp: Khi dùng bên trong hàm tạo hoặc lớp, this đề cập đến instance mới tạo. Ràng buộc rõ ràng: Sử dụng call(), apply() hoặc bind(), bạn có thể đặt rõ ràng this đề cập đến gì. Hàm mũi tên: Không giống hàm thông thường, hàm mũi tên không có this riêng; thay vào đó, chúng nắm bắt this từ phạm vi bao quanh (từ vựng)."
40,42. Phạm vi từ vựng hoạt động với từ khóa this trong JavaScript như thế nào?,"Trong JavaScript, phạm vi từ vựng chủ yếu áp dụng cho giải quyết biến, trong khi hành vi của từ khóa this được xác định bởi cách hàm được gọi, không phải vị trí trong mã. Giá trị của this được xác định động tại thời gian chạy dựa trên ngữ cảnh hàm (ví dụ: gọi như phương thức, ngữ cảnh toàn cục hoặc với call, apply hoặc bind). Ở đây, this đề cập đến obj vì hàm được gọi như phương thức của đối tượng. Phạm vi từ vựng ảnh hưởng tra cứu biến nhưng không thay đổi cách this hoạt động."
41,43. Giải thích cách đọc và viết file bằng JavaScript?,Hàm readFile() dùng cho hoạt động đọc. Hàm writeFile() dùng cho hoạt động viết.
42,44. Kiểu biến (Variable Typing) trong JavaScript được gọi là gì?,"Kiểu biến là loại biến dùng để lưu số và sử dụng cùng biến đó để gán ""chuỗi""."
43,45. Hoisting trong JavaScript là gì?,"Hoisting trong JavaScript là hành vi nơi khai báo biến và hàm được di chuyển đến đầu phạm vi chứa chúng trong quá trình biên dịch, trước khi mã được thực thi. Điều này nghĩa là bạn có thể tham chiếu biến và hàm trước khi chúng được khai báo trong mã. Tuy nhiên, chỉ khai báo được hoisting, không phải khởi tạo. Trong trường hợp này, khai báo của a được hoisting, nhưng giá trị (5) không được gán cho đến khi thực thi mã đạt dòng đó. Hoisting áp dụng khác nhau cho var, let, const và khai báo hàm."
44,46. Giải thích cách phát hiện hệ điều hành trên máy client?,"Để phát hiện hệ điều hành trên máy client, có thể đơn giản sử dụng thuộc tính navigator.appVersion hoặc navigator.userAgent. Thuộc tính Navigator appVersion là thuộc tính chỉ đọc và trả về chuỗi đại diện cho thông tin phiên bản của trình duyệt."
45,47. Các loại hộp pop-up có sẵn trong JavaScript là gì?,"Có ba loại hộp pop-up có sẵn trong JavaScript: Alert, Confirm, Prompt."
46,"48. Module JavaScript là gì, và làm thế nào để import/export chúng?","Module JavaScript cho phép chia mã thành các phần nhỏ, tái sử dụng. Chúng cho phép export biến, hàm hoặc đối tượng từ file này và import vào file khác. Để export phần tử, sử dụng export (tên hoặc mặc định). Để import, sử dụng import. Module giúp tổ chức mã và tránh ô nhiễm không gian tên toàn cục. Chúng được hỗ trợ gốc trong JavaScript hiện đại qua câu lệnh import và export."
47,49. Giải thích khái niệm ghi nhớ (memoization) trong JavaScript?,"Ghi nhớ trong JavaScript là kỹ thuật tối ưu hóa lưu kết quả của các cuộc gọi hàm tốn kém và tái sử dụng khi đầu vào giống lại. Điều này giảm số lượng tính toán bằng cách lưu cache kết quả. Ghi nhớ thường được triển khai sử dụng đối tượng hoặc map để lưu đối số hàm và kết quả tương ứng. Khi hàm được gọi với cùng đối số, kết quả cache được trả về thay vì tính lại. Điều này cải thiện hiệu suất, đặc biệt cho hàm có cuộc gọi lặp và tính toán tốn kém."
48,"50. Call, apply và bind thay đổi this như thế nào?","JavaScript cho phép kiểm soát this bằng call, apply và bind. Chúng đặt this trỏ đến gì khi hàm chạy, và khác nhau về thời điểm chạy và cách nhận đối số. call: Gọi hàm ngay lập tức, đặt this thành đối số đầu; đối số còn lại truyền từng cái một. apply: Gọi hàm ngay lập tức, như call, nhưng nhận đối số dưới dạng mảng đơn. bind: Không chạy ngay; trả về hàm mới với this đặt vĩnh viễn (và tùy chọn một số đối số được điền trước)."
49,51. Chế độ 'Strict' trong JavaScript là gì và làm thế nào để kích hoạt nó?,"Chế độ Strict là tính năng mới trong ECMAScript 5 cho phép đặt chương trình hoặc hàm vào ngữ cảnh hoạt động ""nghiêm ngặt"". Ngữ cảnh nghiêm ngặt này ngăn một số hành động và ném nhiều ngoại lệ hơn. Câu lệnh ""use strict"" hướng dẫn trình duyệt sử dụng chế độ Strict, là tập hợp tính năng giảm và an toàn hơn của JavaScript."
50,52. Giải thích khái niệm promise và cách chúng hoạt động.,"Promise trong JavaScript là đối tượng đại diện cho kết quả của hoạt động bất đồng bộ. Nó có thể ở một trong ba trạng thái: pending, fulfilled (resolved) hoặc rejected. Bạn tạo promise bằng new Promise(), truyền hàm thực thi với callback resolve và reject. Khi hoạt động thành công, gọi resolve(); nếu thất bại, sử dụng reject(). Promise được xử lý bằng .then() cho thành công và .catch() cho thất bại. Chúng có thể được xâu chuỗi để xử lý chuỗi nhiệm vụ bất đồng bộ một cách dễ đọc hơn."
51,53. Làm thế nào để giải thích closure trong JavaScript và khi nào sử dụng nó?,Closure được tạo khi hàm con giữ môi trường của phạm vi cha ngay cả sau khi hàm cha đã thực thi. Closure là biến địa phương liên quan đến hàm. Closure cung cấp kiểm soát tốt hơn mã khi sử dụng chúng. Kết quả: 1 1 1
