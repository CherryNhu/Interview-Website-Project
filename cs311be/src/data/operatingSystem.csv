STT,Câu hỏi,Trả lời
1,Tiến trình và bảng tiến trình là gì?,"Tiến trình: Là một phiên bản của chương trình đang thực thi, ví dụ: trình duyệt web hoặc cửa sổ lệnh (shell). Hệ điều hành quản lý tất cả các tiến trình đang chạy, phân bổ thời gian sử dụng bộ xử lý và các tài nguyên như bộ nhớ hoặc ổ đĩa. Bảng tiến trình: Là bảng được hệ điều hành duy trì để theo dõi trạng thái của tất cả các tiến trình, bao gồm tài nguyên mà tiến trình sử dụng và trạng thái hiện tại của nó."
2,Các trạng thái khác nhau của tiến trình là gì?,"Tiến trình có thể ở một trong ba trạng thái: Chạy (Running): Tiến trình có tất cả tài nguyên cần thiết và được phép sử dụng bộ xử lý. Chỉ một tiến trình ở trạng thái chạy tại một thời điểm. Sẵn sàng (Ready): Tiến trình chờ được cấp phép sử dụng bộ xử lý. Chờ (Waiting): Tiến trình chờ sự kiện bên ngoài (như đầu vào người dùng hoặc truy cập ổ đĩa). Trong hệ điều hành thực, trạng thái sẵn sàng và chờ được triển khai dưới dạng hàng đợi chứa các tiến trình."
3,Luồng (Thread) là gì?,"Luồng: Là một luồng thực thi đơn lẻ trong một tiến trình, đôi khi được gọi là tiến trình nhẹ vì có một số đặc điểm giống tiến trình. Luồng giúp cải thiện ứng dụng thông qua tính song song. Ví dụ: trong trình duyệt, mỗi tab có thể là một luồng; MS Word sử dụng nhiều luồng để định dạng văn bản, xử lý đầu vào, v.v."
4,Sự khác biệt giữa tiến trình và luồng là gì?,"Tiến trình: Là chương trình đang thực thi, độc lập với các tiến trình khác, có không gian địa chỉ riêng. Luồng: Là đoạn mã nhỏ nhất trong tiến trình, được quản lý độc lập bởi bộ lập lịch. Các luồng trong cùng tiến trình chia sẻ không gian địa chỉ, bao gồm đoạn mã, dữ liệu và tài nguyên hệ điều hành như tệp đang mở, nhưng mỗi luồng có bộ đếm chương trình (PC), tập thanh ghi và không gian ngăn xếp riêng."
5,Bộ lập lịch tiến trình (Process Scheduler) là gì?,"Bộ lập lịch tiến trình là thành phần của hệ điều hành quyết định tiến trình nào được chạy, khi nào và trong bao lâu, nhằm tối ưu hóa hiệu suất hệ thống, sử dụng CPU và thời gian phản hồi."
6,Các loại bộ lập lịch là gì?,Bộ lập lịch dài hạn: Quyết định tiến trình nào được đưa vào hàng đợi sẵn sàng. Bộ lập lịch ngắn hạn: Chọn tiến trình từ hàng đợi sẵn sàng để chạy trên CPU. Bộ lập lịch trung hạn: Quản lý tiến trình bị tạm hoãn (swapped out) để nhường bộ nhớ cho tiến trình khác.
7,CPU Scheduling là gì?,"CPU Scheduling là quá trình hệ điều hành chọn tiến trình từ hàng đợi sẵn sàng để phân bổ CPU, nhằm tối ưu hóa hiệu suất, độ trễ và thông lượng."
8,Các thuật toán lập lịch CPU là gì?,Các thuật toán lập lịch CPU: FCFS (First Come First Serve): Thực thi tiến trình theo thứ tự đến. SJF (Shortest Job First): Ưu tiên tiến trình có thời gian thực thi ngắn nhất. SRTF (Shortest Remaining Time First): Phiên bản chiếm ưu tiên của SJF. Round Robin: Phân bổ thời gian CPU cho mỗi tiến trình theo vòng. Priority Scheduling: Ưu tiên tiến trình theo mức ưu tiên. Multilevel Queue Scheduling: Chia tiến trình thành nhiều hàng đợi với các thuật toán lập lịch khác nhau.
9,Deadlock trong hệ điều hành là gì?,"Deadlock là trạng thái mà hai hoặc nhiều tiến trình bị kẹt, mỗi tiến trình giữ một tài nguyên và chờ tài nguyên mà tiến trình khác đang giữ, dẫn đến không tiến trình nào có thể tiếp tục."
10,Các điều kiện cần để xảy ra Deadlock là gì?,Bốn điều kiện cần cho Deadlock: Giữ và chờ (Hold and Wait): Tiến trình giữ tài nguyên và chờ thêm tài nguyên. Chiếm dụng không trả (No Preemption): Tài nguyên không thể bị lấy đi từ tiến trình. Phụ thuộc vòng (Circular Wait): Các tiến trình tạo thành vòng chờ tài nguyên. Loại trừ lẫn nhau (Mutual Exclusion): Tài nguyên chỉ có thể được giữ bởi một tiến trình tại một thời điểm.
11,Làm thế nào để ngăn chặn Deadlock?,"Ngăn chặn Deadlock bằng: Phá bỏ giữ và chờ: Yêu cầu tiến trình yêu cầu tất cả tài nguyên trước khi chạy. Cho phép chiếm dụng: Cho phép hệ điều hành lấy tài nguyên từ tiến trình. Tránh vòng chờ: Áp dụng thứ tự tài nguyên cố định. Loại bỏ loại trừ lẫn nhau: Không khả thi trong nhiều trường hợp, vì một số tài nguyên cần độc quyền."
12,Hệ điều hành là gì?,"Hệ điều hành là phần mềm hệ thống quản lý tài nguyên phần cứng và cung cấp dịch vụ cho phần mềm ứng dụng, đóng vai trò trung gian giữa người dùng và phần cứng."
13,Các chức năng chính của hệ điều hành là gì?,"Các chức năng chính: Quản lý tiến trình: Tạo, thực thi, và hủy tiến trình. Quản lý bộ nhớ: Phân bổ và giải phóng bộ nhớ. Quản lý thiết bị: Điều khiển phần cứng như ổ đĩa, bàn phím. Quản lý tệp: Tạo, xóa, đọc, ghi tệp. Bảo mật: Bảo vệ dữ liệu và tài nguyên. Giao diện người dùng: Cung cấp giao diện (GUI hoặc CLI) để tương tác."
14,Các loại hệ điều hành là gì?,Hệ điều hành đơn nhiệm: Chạy một chương trình tại một thời điểm. Hệ điều hành đa nhiệm: Chạy nhiều chương trình đồng thời. Hệ điều hành thời gian thực: Đáp ứng trong thời gian xác định. Hệ điều hành phân tán: Quản lý nhiều hệ thống như một hệ thống duy nhất. Hệ điều hành mạng: Hỗ trợ kết nối mạng.
15,Multitasking là gì?,"Multitasking là khả năng của hệ điều hành thực hiện nhiều tác vụ đồng thời bằng cách chuyển đổi nhanh giữa các tiến trình, tạo cảm giác chúng chạy song song."
16,Multithreading là gì?,"Multithreading là khả năng một tiến trình thực thi nhiều luồng đồng thời, chia sẻ không gian địa chỉ và tài nguyên, cải thiện hiệu suất và song song hóa."
17,Sự khác biệt giữa Multitasking và Multithreading là gì?,"Multitasking: Chạy nhiều tiến trình độc lập trên CPU, mỗi tiến trình có không gian địa chỉ riêng. Multithreading: Chạy nhiều luồng trong cùng một tiến trình, chia sẻ không gian địa chỉ và tài nguyên, nhẹ hơn multitasking."
18,Quản lý bộ nhớ trong hệ điều hành là gì?,"Quản lý bộ nhớ là chức năng của hệ điều hành phân bổ và giải phóng bộ nhớ cho các tiến trình, đảm bảo sử dụng hiệu quả và ngăn chặn xung đột."
19,Các kỹ thuật quản lý bộ nhớ là gì?,Phân vùng (Partitioning): Chia bộ nhớ thành các vùng cố định hoặc động. Phân trang (Paging): Chia bộ nhớ thành các trang kích thước cố định. Phân đoạn (Segmentation): Chia bộ nhớ theo các đoạn logic. Bộ nhớ ảo (Virtual Memory): Mô phỏng bộ nhớ lớn hơn bằng cách sử dụng ổ đĩa.
20,Bộ nhớ ảo (Virtual Memory) là gì?,"Bộ nhớ ảo là kỹ thuật cho phép tiến trình sử dụng bộ nhớ lớn hơn bộ nhớ vật lý bằng cách ánh xạ địa chỉ ảo sang địa chỉ vật lý, sử dụng ổ đĩa làm bộ nhớ phụ khi cần."
21,Paging trong hệ điều hành là gì?,"Paging là kỹ thuật quản lý bộ nhớ chia bộ nhớ vật lý và không gian địa chỉ tiến trình thành các trang kích thước cố định, ánh xạ trang ảo sang trang vật lý để quản lý hiệu quả."
22,Swapping trong hệ điều hành là gì?,Swapping là quá trình di chuyển một tiến trình từ bộ nhớ chính sang ổ đĩa (swap space) và ngược lại để giải phóng bộ nhớ cho các tiến trình khác.
23,Page Fault là gì?,"Page Fault xảy ra khi một tiến trình cố gắng truy cập một trang không có trong bộ nhớ chính, khiến hệ điều hành phải nạp trang từ ổ đĩa."
24,File System trong hệ điều hành là gì?,"File System là cách hệ điều hành tổ chức và quản lý tệp trên thiết bị lưu trữ, như FAT32, NTFS, ext4, cung cấp cách truy cập và lưu trữ dữ liệu."
25,Các loại File System là gì?,"FAT32: Hệ thống tệp đơn giản, tương thích rộng. NTFS: Hỗ trợ bảo mật, nén và tệp lớn. ext4: Hệ thống tệp Linux, hiệu suất cao. APFS: Hệ thống tệp Apple, tối ưu cho SSD. HFS+: Hệ thống tệp cũ của Apple."
26,Inter-Process Communication (IPC) là gì?,"IPC là cơ chế cho phép các tiến trình trao đổi dữ liệu hoặc tín hiệu, như pipe, hàng đợi tin nhắn, semaphore, hoặc bộ nhớ chia sẻ."
27,Pipe trong IPC là gì?,"Pipe là phương thức IPC cho phép truyền dữ liệu một chiều giữa hai tiến trình, thường là tiến trình cha-con, với pipe không tên (trong cùng tiến trình) hoặc pipe có tên (giữa các tiến trình không liên quan)."
28,Semaphore là gì?,"Semaphore là biến đồng bộ hóa dùng để kiểm soát truy cập tài nguyên chia sẻ giữa các tiến trình hoặc luồng, thường dùng để ngăn chặn tranh chấp tài nguyên."
29,Mutex là gì?,"Mutex (Mutual Exclusion) là cơ chế đồng bộ hóa đảm bảo chỉ một luồng hoặc tiến trình truy cập tài nguyên tại một thời điểm, ngăn chặn xung đột."
30,Sự khác biệt giữa Semaphore và Mutex là gì?,"Semaphore: Có thể cho phép nhiều luồng truy cập tài nguyên với số lượng giới hạn (counting semaphore) hoặc nhị phân (binary semaphore). Mutex: Chỉ cho phép một luồng truy cập tài nguyên tại một thời điểm, tập trung vào loại trừ lẫn nhau."
31,Thread Synchronization là gì?,"Thread Synchronization là quá trình điều phối các luồng để đảm bảo truy cập an toàn vào tài nguyên chia sẻ, sử dụng cơ chế như mutex, semaphore, hoặc khóa."
32,Critical Section là gì?,Critical Section là đoạn mã mà chỉ một luồng hoặc tiến trình được phép thực thi tại một thời điểm để tránh xung đột khi truy cập tài nguyên chia sẻ.
33,Context Switching là gì?,"Context Switching là quá trình lưu trạng thái của một tiến trình hoặc luồng đang chạy, sau đó khôi phục trạng thái của tiến trình/luồng khác để CPU thực thi tiếp, hỗ trợ multitasking."
34,Preemptive Scheduling là gì?,"Preemptive Scheduling là kỹ thuật lập lịch cho phép hệ điều hành tạm dừng một tiến trình đang chạy để nhường CPU cho tiến trình khác, dựa trên ưu tiên hoặc thời gian."
35,Non-Preemptive Scheduling là gì?,Non-Preemptive Scheduling là kỹ thuật lập lịch mà tiến trình đang chạy sẽ giữ CPU cho đến khi hoàn thành hoặc tự nguyện nhường CPU (như vào trạng thái chờ).
36,Starvation trong hệ điều hành là gì?,Starvation là tình trạng một tiến trình không được cấp CPU hoặc tài nguyên do các tiến trình khác có ưu tiên cao hơn liên tục chiếm dụng tài nguyên.
37,Làm thế nào để tránh Starvation?,"Tránh Starvation bằng: Tăng ưu tiên động (Aging): Tăng dần ưu tiên của tiến trình chờ lâu. Sử dụng thuật toán công bằng: Như Round Robin, đảm bảo mỗi tiến trình đều được cấp CPU."
38,Aging trong lập lịch là gì?,Aging là kỹ thuật tăng dần mức ưu tiên của một tiến trình hoặc luồng đã chờ lâu trong hàng đợi sẵn sàng để tránh Starvation.
39,Real-Time Operating System (RTOS) là gì?,"RTOS là hệ điều hành được thiết kế để xử lý các tác vụ với thời gian thực, đảm bảo phản hồi trong giới hạn thời gian nghiêm ngặt, thường dùng trong hệ thống nhúng."
40,Các loại RTOS là gì?,Hard Real-Time: Đảm bảo đáp ứng thời hạn nghiêm ngặt (ví dụ: hệ thống điều khiển máy bay). Soft Real-Time: Cho phép trễ nhỏ mà không gây hậu quả nghiêm trọng (ví dụ: phát video). Firm Real-Time: Trễ có thể chấp nhận nhưng không thường xuyên (ví dụ: hệ thống viễn thông).
41,Interrupt là gì?,"Interrupt là tín hiệu từ phần cứng hoặc phần mềm yêu cầu CPU tạm dừng tác vụ hiện tại để xử lý một sự kiện khẩn cấp, như đầu vào từ bàn phím hoặc lỗi phần cứng."
42,Các loại Interrupt là gì?,"Interrupt phần cứng: Từ thiết bị như bàn phím, chuột. Interrupt phần mềm: Do chương trình hoặc hệ điều hành tạo ra, như lỗi chia cho 0. Interrupt đồng bộ (Synchronous): Xảy ra do thực thi lệnh CPU. Interrupt bất đồng bộ (Asynchronous): Xảy ra từ sự kiện bên ngoài."
43,Interrupt Handling là gì?,"Interrupt Handling là quá trình hệ điều hành lưu trạng thái hiện tại, xử lý sự kiện ngắt, và khôi phục trạng thái để tiếp tục thực thi tiến trình bị gián đoạn."
44,System Call là gì?,"System Call là giao diện cho phép chương trình người dùng yêu cầu dịch vụ từ hệ điều hành, như truy cập tệp, quản lý tiến trình, hoặc giao tiếp mạng."
45,Các loại System Call là gì?,"Quản lý tiến trình: fork(), exec(), wait(). Quản lý tệp: open(), read(), write(), close(). Quản lý thiết bị: ioctl(), read(), write(). Giao tiếp: pipe(), shmget() (bộ nhớ chia sẻ). Bảo mật: chmod(), chown()."
46,Kernel là gì?,"Kernel là lõi của hệ điều hành, quản lý tài nguyên phần cứng, cung cấp giao diện cho phần mềm ứng dụng, và xử lý các tác vụ như quản lý tiến trình, bộ nhớ, và thiết bị."
47,Các loại Kernel là gì?,"Monolithic Kernel: Tất cả dịch vụ hệ điều hành chạy trong cùng không gian kernel (ví dụ: Linux). Microkernel: Chỉ các dịch vụ cốt lõi chạy trong kernel, các dịch vụ khác chạy ở chế độ người dùng (ví dụ: Minix). Hybrid Kernel: Kết hợp đặc điểm của monolithic và microkernel (ví dụ: Windows). Exokernel: Tối thiểu hóa vai trò kernel, cho phép ứng dụng kiểm soát tài nguyên trực tiếp."
48,User Mode và Kernel Mode là gì?,"User Mode: Chế độ mà ứng dụng người dùng chạy, có quyền truy cập hạn chế để bảo vệ hệ thống. Kernel Mode: Chế độ mà kernel chạy, có toàn quyền truy cập phần cứng và tài nguyên hệ thống."
49,Sự khác biệt giữa User Mode và Kernel Mode là gì?,"User Mode: Quyền hạn thấp, không truy cập trực tiếp phần cứng, an toàn hơn. Kernel Mode: Quyền hạn cao, truy cập trực tiếp phần cứng, thực thi các tác vụ hệ thống quan trọng nhưng dễ gây lỗi nếu không quản lý tốt."
50,Virtual Machine là gì?,"Virtual Machine là môi trường ảo mô phỏng phần cứng máy tính, cho phép chạy nhiều hệ điều hành trên cùng một máy vật lý, được quản lý bởi hypervisor."
51,Hypervisor là gì?,"Hypervisor là phần mềm hoặc phần cứng quản lý các máy ảo, phân bổ tài nguyên phần cứng như CPU, bộ nhớ, và ổ đĩa giữa các máy ảo."
52,Các loại Hypervisor là gì?,"Type 1 (Bare-Metal): Chạy trực tiếp trên phần cứng (ví dụ: VMware ESXi, Xen). Type 2 (Hosted): Chạy trên hệ điều hành chủ (ví dụ: VirtualBox, VMware Workstation)."
53,Scheduling Criteria là gì?,"Scheduling Criteria là các tiêu chí đánh giá hiệu quả của thuật toán lập lịch, bao gồm: Thời gian chờ (Waiting Time), Thời gian xử lý (Turnaround Time), Thông lượng (Throughput), Sử dụng CPU, Thời gian phản hồi (Response Time)."
54,Thrashing là gì?,"Thrashing là trạng thái hệ thống dành quá nhiều thời gian để chuyển đổi trang (swapping) giữa bộ nhớ và ổ đĩa do thiếu bộ nhớ vật lý, làm giảm hiệu suất đáng kể."
55,Làm thế nào để giảm Thrashing?,"Giảm Thrashing bằng: Tăng bộ nhớ vật lý, Giảm số lượng tiến trình đồng thời, Tối ưu hóa thuật toán thay thế trang, Sử dụng bộ nhớ ảo hiệu quả hơn."
56,Demand Paging là gì?,"Demand Paging là kỹ thuật chỉ nạp trang vào bộ nhớ khi cần (khi xảy ra Page Fault), thay vì nạp toàn bộ tiến trình, giúp tiết kiệm bộ nhớ."
57,Page Replacement Algorithm là gì?,"Page Replacement Algorithm quyết định trang nào trong bộ nhớ sẽ bị thay thế khi cần nạp trang mới, ví dụ: FIFO (First In First Out), LRU (Least Recently Used), Optimal Page Replacement."
58,FIFO Page Replacement là gì?,"FIFO (First In First Out) thay thế trang được nạp vào bộ nhớ đầu tiên khi cần không gian, đơn giản nhưng không tối ưu vì không xem xét tần suất sử dụng."
59,LRU Page Replacement là gì?,"LRU (Least Recently Used) thay thế trang ít được sử dụng gần đây nhất, dựa trên giả định rằng trang sử dụng gần đây sẽ được dùng lại."
60,Optimal Page Replacement là gì?,"Optimal Page Replacement thay thế trang sẽ không được sử dụng trong thời gian dài nhất trong tương lai, lý tưởng nhưng không khả thi trong thực tế do cần dự đoán tương lai."
61,Segmentation là gì?,"Segmentation là kỹ thuật quản lý bộ nhớ chia không gian địa chỉ tiến trình thành các đoạn logic (như code, data, stack), ánh xạ sang bộ nhớ vật lý."
62,Sự khác biệt giữa Paging và Segmentation là gì?,"Paging: Chia bộ nhớ thành các trang kích thước cố định, không liên quan đến logic chương trình. Segmentation: Chia bộ nhớ theo các đoạn logic, phản ánh cấu trúc chương trình, linh hoạt nhưng phức tạp hơn."
63,Fragmentation là gì?,"Fragmentation là hiện tượng bộ nhớ bị phân mảnh, gây lãng phí không gian. Internal Fragmentation: Lãng phí trong trang hoặc phân vùng do không sử dụng hết. External Fragmentation: Lãng phí do các khoảng trống không liên tục giữa các phân vùng."
64,Làm thế nào để giảm Fragmentation?,Giảm Fragmentation bằng: Sử dụng Paging để tránh phân mảnh ngoài. Nén bộ nhớ (Compaction) để loại bỏ phân mảnh ngoài. Tối ưu hóa phân bổ bộ nhớ để giảm phân mảnh trong.
65,Disk Scheduling là gì?,"Disk Scheduling là quá trình hệ điều hành quyết định thứ tự xử lý các yêu cầu truy cập ổ đĩa để tối ưu hóa hiệu suất, giảm thời gian tìm kiếm và độ trễ."
66,Các thuật toán Disk Scheduling là gì?,"FCFS: Xử lý yêu cầu theo thứ tự đến. SSTF (Shortest Seek Time First): Ưu tiên yêu cầu gần vị trí đầu đọc/ghi nhất. SCAN: Di chuyển đầu đọc qua lại toàn bộ ổ đĩa. C-SCAN: SCAN vòng, chỉ di chuyển một hướng. LOOK: Tương tự SCAN nhưng không đi đến cuối ổ đĩa nếu không có yêu cầu. C-LOOK: Phiên bản vòng của LOOK."
67,FCFS Disk Scheduling là gì?,"FCFS (First Come First Serve) xử lý các yêu cầu truy cập ổ đĩa theo thứ tự đến, đơn giản nhưng không tối ưu hóa thời gian tìm kiếm."
68,SSTF Disk Scheduling là gì?,"SSTF (Shortest Seek Time First) chọn yêu cầu gần vị trí đầu đọc/ghi nhất, giảm thời gian tìm kiếm nhưng có thể gây Starvation cho các yêu cầu xa."
69,SCAN Disk Scheduling là gì?,"SCAN di chuyển đầu đọc/ghi qua toàn bộ ổ đĩa, xử lý các yêu cầu trên đường đi, quay lại khi đến cuối, còn gọi là thuật toán thang máy."
70,C-SCAN Disk Scheduling là gì?,"C-SCAN (Circular SCAN) di chuyển đầu đọc/ghi một chiều, quay lại điểm bắt đầu sau khi đến cuối, đảm bảo xử lý công bằng hơn SCAN."
71,LOOK Disk Scheduling là gì?,"LOOK tương tự SCAN nhưng chỉ di chuyển đầu đọc/ghi đến yêu cầu xa nhất, không đi đến cuối ổ đĩa nếu không cần, tiết kiệm thời gian."
72,C-LOOK Disk Scheduling là gì?,"C-LOOK là phiên bản vòng của LOOK, di chuyển đầu đọc/ghi một chiều đến yêu cầu xa nhất, quay lại yêu cầu gần nhất mà không đi qua toàn bộ ổ đĩa."
73,File Allocation Methods là gì?,File Allocation Methods là các kỹ thuật phân bổ không gian lưu trữ cho tệp: Contiguous Allocation: Tệp được lưu liên tục. Linked Allocation: Tệp được lưu dưới dạng danh sách liên kết các khối. Indexed Allocation: Tệp sử dụng chỉ mục để theo dõi các khối dữ liệu.
74,Contiguous Allocation là gì?,"Contiguous Allocation lưu trữ tệp trong các khối liên tục trên ổ đĩa, nhanh nhưng dễ gây phân mảnh ngoài."
75,Linked Allocation là gì?,"Linked Allocation lưu trữ tệp dưới dạng danh sách liên kết, mỗi khối chứa con trỏ đến khối tiếp theo, linh hoạt nhưng truy cập tuần tự chậm."
76,Indexed Allocation là gì?,"Indexed Allocation lưu trữ con trỏ đến tất cả các khối của tệp trong một khối chỉ mục, cho phép truy cập ngẫu nhiên nhanh nhưng cần không gian cho chỉ mục."
77,Inode trong hệ thống tệp là gì?,"Inode là cấu trúc dữ liệu trong hệ thống tệp (như ext4) lưu trữ siêu dữ liệu về tệp (kích thước, quyền, vị trí khối dữ liệu), nhưng không chứa tên tệp."
78,Directory trong hệ thống tệp là gì?,"Directory là cấu trúc đặc biệt trong hệ thống tệp lưu trữ ánh xạ giữa tên tệp và inode, tổ chức tệp trong hệ thống phân cấp."
79,Access Control List (ACL) là gì?,"ACL là danh sách các quyền truy cập liên kết với tệp hoặc thư mục, xác định người dùng hoặc nhóm nào có thể thực hiện các thao tác như đọc, ghi, thực thi."
80,File Permission trong hệ điều hành là gì?,"File Permission xác định quyền truy cập vào tệp (đọc, ghi, thực thi) cho chủ sở hữu, nhóm, và người khác, thường biểu diễn bằng số (như 755) hoặc ký hiệu (như rwxr-xr-x)."
81,Process Control Block (PCB) là gì?,"PCB là cấu trúc dữ liệu trong hệ điều hành lưu trữ thông tin về tiến trình, như ID, trạng thái, bộ đếm chương trình, thanh ghi, và tài nguyên được sử dụng."
82,Thread Control Block (TCB) là gì?,"TCB là cấu trúc dữ liệu lưu trữ thông tin về luồng, như ID luồng, bộ đếm chương trình, thanh ghi, và ngăn xếp, tương tự PCB nhưng dành cho luồng."
83,Fork() trong hệ điều hành là gì?,"Fork() là system call tạo một tiến trình con là bản sao của tiến trình cha, chia sẻ mã nhưng có không gian địa chỉ riêng, thường dùng trong hệ thống Unix/Linux."
84,Exec() trong hệ điều hành là gì?,"Exec() là system call thay thế hình ảnh bộ nhớ của tiến trình hiện tại bằng chương trình mới, giữ nguyên ID tiến trình nhưng tải mã và dữ liệu mới."
85,Zombie Process là gì?,Zombie Process là tiến trình đã hoàn thành nhưng vẫn tồn tại trong bảng tiến trình vì tiến trình cha chưa thu hồi trạng thái của nó thông qua wait().
86,Orphan Process là gì?,"Orphan Process là tiến trình mà tiến trình cha đã kết thúc, được hệ điều hành chuyển giao cho tiến trình init (PID 1) để quản lý."
87,Interprocess Synchronization là gì?,"Interprocess Synchronization là quá trình điều phối các tiến trình để đảm bảo truy cập an toàn và đúng thứ tự vào tài nguyên chia sẻ, sử dụng semaphore, mutex, hoặc monitor."
88,Monitor trong hệ điều hành là gì?,"Monitor là cấu trúc đồng bộ hóa cung cấp môi trường an toàn để các luồng truy cập tài nguyên chia sẻ, tự động quản lý loại trừ lẫn nhau và điều kiện chờ."
89,Làm thế nào để phát hiện Deadlock?,Phát hiện Deadlock bằng: Resource Allocation Graph (RAG): Kiểm tra vòng chờ trong đồ thị phân bổ tài nguyên. Banker’s Algorithm: Đảm bảo trạng thái an toàn để tránh Deadlock. Wait-for Graph: Theo dõi quan hệ chờ giữa các tiến trình.
90,Banker’s Algorithm là gì?,"Banker’s Algorithm là thuật toán tránh Deadlock bằng cách kiểm tra trạng thái an toàn trước khi phân bổ tài nguyên, đảm bảo hệ thống không rơi vào Deadlock."
91,Resource Allocation Graph (RAG) là gì?,"RAG là đồ thị biểu diễn trạng thái hệ thống với các đỉnh (tiến trình, tài nguyên) và cạnh (phân bổ, yêu cầu), giúp phát hiện trực tiếp vòng chờ và Deadlock."
92,Access Time trong hệ thống đĩa là gì?,"Access Time là thời gian tổng để truy cập dữ liệu trên ổ đĩa, bao gồm Seek Time (di chuyển cánh tay đĩa), Rotational Latency (chờ đĩa xoay), và Transfer Time (truyền dữ liệu)."
93,Rotational Latency là gì?,Rotational Latency là thời gian chờ để đĩa xoay đưa sector cần truy cập đến vị trí đầu đọc/ghi. Thuật toán lập lịch đĩa giảm thiểu độ trễ quay là tốt hơn.
94,Seek Time là gì?,Seek Time là thời gian để cánh tay đĩa di chuyển đến track chứa dữ liệu cần đọc/ghi. Thuật toán lập lịch đĩa giảm thiểu thời gian tìm kiếm trung bình là tốt hơn.
95,Belady's Anomaly là gì?,"Belady's Anomaly là hiện tượng số lượng lỗi trang (page faults) tăng khi tăng số khung trang (page frames) trong một số thuật toán thay thế trang, đặc biệt với FIFO."
96,Điều gì xảy ra nếu một mutex không đệ quy bị khóa nhiều lần?,"Deadlock: Nếu một luồng đã khóa mutex cố gắng khóa lại, nó sẽ vào danh sách chờ của mutex, dẫn đến Deadlock vì không có luồng nào khác có thể mở khóa. Hệ điều hành có thể kiểm tra chủ sở hữu mutex để tránh Deadlock."
97,Lợi ích của hệ thống đa xử lý là gì?,Lợi ích: Hiệu suất cao hơn: Nhiều CPU xử lý song song. Hỗ trợ nhiều ứng dụng: Chạy nhiều chương trình đồng thời. Đa nhiệm trong ứng dụng: Tăng hiệu quả ứng dụng. Thông lượng cao: Xử lý nhiều tác vụ nhanh. Chia sẻ phần cứng: Nhiều CPU dùng chung tài nguyên.
98,Hệ thống thời gian thực là gì?,"Hệ thống thời gian thực là hệ thống phải phản hồi trong khoảng thời gian xác định, đảm bảo đáp ứng các ràng buộc thời gian, thường dùng trong hệ thống nhúng hoặc điều khiển."
99,Làm thế nào để khôi phục từ Deadlock?,Khôi phục từ Deadlock bằng: Kết thúc tiến trình: Hủy tất cả hoặc từng tiến trình bị Deadlock. Chiếm dụng tài nguyên: Hoàn tác (rollback) hoặc chọn tiến trình nạn nhân để giải phóng tài nguyên.
100,Các yếu tố xác định liệu một thuật toán phát hiện Deadlock có cần sử dụng trong hệ thống tránh Deadlock?,"Các yếu tố: Tần suất xảy ra Deadlock: Nếu thuật toán làm tăng khả năng Deadlock, cần phát hiện. Số lượng tiến trình bị ảnh hưởng: Nếu nhiều tiến trình bị kẹt, thuật toán phát hiện là cần thiết để giảm thiểu tác động."
101,Giải thích đồ thị phân bổ tài nguyên (Resource Allocation Graph).,"Đồ thị phân bổ tài nguyên (RAG) biểu diễn trạng thái hệ thống với các tiến trình và tài nguyên, sử dụng đỉnh (tiến trình, tài nguyên) và cạnh (phân bổ, yêu cầu). RAG giúp phát hiện trực tiếp vòng chờ và Deadlock."
